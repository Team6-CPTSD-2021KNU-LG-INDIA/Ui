"use strict";

var _enzyme = require("enzyme");

var _FloatingLayer = require("@enact/ui/FloatingLayer");

var _ContextualPopupDecorator = require("../ContextualPopupDecorator");

var _Button = _interopRequireDefault(require("../../Button"));

var _jsxRuntime = require("react/jsx-runtime");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var ContextualButton = (0, _ContextualPopupDecorator.ContextualPopupDecorator)(_Button["default"]);
describe('ContextualPopupDecorator Specs', function () {
  test('should bind callback to instance', function () {
    var called = false; // Create a context with a prop on it we can use to detect access to this prop inside the
    // instance method.

    var CallbackInterceptor = /*#__PURE__*/function () {
      function CallbackInterceptor() {
        _classCallCheck(this, CallbackInterceptor);
      }

      _createClass(CallbackInterceptor, [{
        key: "containerNode",
        get: function get() {
          called = true;
          return null;
        }
      }]);

      return CallbackInterceptor;
    }();

    var subject = (0, _enzyme.mount)( /*#__PURE__*/(0, _jsxRuntime.jsx)(ContextualButton, {
      popupComponent: _Button["default"],
      children: "Button"
    })); // Call `positionContextualPopup` setting `this` to our interceptor.  Bound function should
    // ignore the value of `this` we pass in.  If not, it will access `containerNode` above.

    Reflect.apply(subject.instance().positionContextualPopup, new CallbackInterceptor(), []);
    var expected = false;
    var actual = called;
    expect(actual).toBe(expected);
  });
  test('should render component into FloatingLayer if open', function () {
    var Root = (0, _FloatingLayer.FloatingLayerDecorator)('div');
    var message = 'goodbye';
    var subject = (0, _enzyme.mount)( /*#__PURE__*/(0, _jsxRuntime.jsx)(Root, {
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(ContextualButton, {
        open: true,
        popupComponent: function popupComponent() {
          return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
            children: message
          });
        },
        children: "Hello"
      })
    }));
    var expected = message;
    var actual = subject.find('FloatingLayer').text();
    expect(actual).toBe(expected);
  });
  test('should not render into FloatingLayer if not open', function () {
    var Root = (0, _FloatingLayer.FloatingLayerDecorator)('div');
    var message = 'goodbye';
    var subject = (0, _enzyme.mount)( /*#__PURE__*/(0, _jsxRuntime.jsx)(Root, {
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(ContextualButton, {
        popupComponent: function popupComponent() {
          return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
            children: message
          });
        },
        children: "Hello"
      })
    }));
    var expected = '';
    var actual = subject.find('FloatingLayer').text();
    expect(actual).toBe(expected);
  });
});