"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Tab", {
  enumerable: true,
  get: function get() {
    return _TabLayout.Tab;
  }
});
exports.TabPanel = exports.TabPanelsBase = exports.TabPanels = exports.PopupTabLayoutDecorator = exports.PopupTabLayoutBase = exports.PopupTabLayout = exports["default"] = void 0;

var _handle = require("@enact/core/handle");

var _kind = _interopRequireDefault(require("@enact/core/kind"));

var _useHandlers = _interopRequireDefault(require("@enact/core/useHandlers"));

var _util = require("@enact/core/util");

var _I18nDecorator = require("@enact/i18n/I18nDecorator");

var _spotlight = _interopRequireDefault(require("@enact/spotlight"));

var _container = require("@enact/spotlight/src/container");

var _target = require("@enact/spotlight/src/target");

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = require("react");

var _compose = _interopRequireDefault(require("ramda/src/compose"));

var _Skinnable = _interopRequireDefault(require("../Skinnable"));

var _Panels = _interopRequireWildcard(require("../Panels"));

var _TabLayout = _interopRequireWildcard(require("../TabLayout"));

var _Popup = _interopRequireDefault(require("../Popup"));

var _PopupTabLayoutModule = _interopRequireDefault(require("./PopupTabLayout.module.css"));

var _jsxRuntime = require("react/jsx-runtime");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

// List all of the props from PopupTabLayout that we want to move from this component's root onto PopupTabLayout.
var popupPropList = ['noAutoDismiss', 'onHide', 'onKeyDown', 'onShow', 'open', 'position', 'scrimType', 'spotlightId', 'spotlightRestrict', 'id', 'className', 'style', 'noAnimation', 'onClose'];
/**
 * Tabbed Layout component in a floating Popup.
 *
 * @class PopupTabLayoutBase
 * @memberof sandstone/PopupTabLayout
 * @extends sandstone/Popup.Popup
 * @extends sandstone/TabLayout.TabLayout
 * @ui
 * @public
 */

var PopupTabLayoutBase = (0, _kind["default"])({
  name: 'PopupTabLayout',
  propTypes:
  /** @lends sandstone/PopupTabLayout.PopupTabLayoutBase.prototype */
  {
    /**
     * Collection of [Tabs]{@link sandstone/PopupTabLayout.Tab} to render.
     *
     * @type {Node}
     * @public
     */
    children: _propTypes["default"].node,

    /**
     * Collapses the vertical tab list into icons only.
     *
     * Only applies to `orientation="vertical"`.  If the tabs do not include icons, a single
     * collapsed icon will be shown.
     *
     * @type {Boolean}
     * @public
     */
    collapsed: _propTypes["default"].bool,

    /**
     * Customizes the component by mapping the supplied collection of CSS class names to the
     * corresponding internal elements and states of this component.
     *
     * @type {Object}
     * @private
     */
    css: _propTypes["default"].object,

    /**
     * Specify dimensions for the layout areas.
     *
     * All 4 combinations must me supplied: each of the elements, tabs and content in both
     * collapsed and expanded state.
     *
     * @type {{tabs: {collapsed: Number, normal: Number}, content: {expanded: number, normal: number}}}
     * @default {
     * 	tabs: {
     * 		collapsed: 236,
     * 		normal: 660
     * 	},
     * 	content: {
     * 		expanded: 1320,
     * 		normal: 1320
     * 	}
     * }
     * @private
     */
    dimensions: _propTypes["default"].shape({
      content: _propTypes["default"].shape({
        expanded: _propTypes["default"].number.isRequired,
        normal: _propTypes["default"].number.isRequired
      }).isRequired,
      tabs: _propTypes["default"].shape({
        collapsed: _propTypes["default"].number.isRequired,
        normal: _propTypes["default"].number.isRequired
      }).isRequired
    }),

    /**
     * The currently selected tab.
     *
     * @type {Number}
     * @public
     */
    index: _propTypes["default"].number,

    /**
     * Disables transition animation.
     *
     * @type {Boolean}
     * @public
     */
    noAnimation: _propTypes["default"].bool,

    /**
     * Called when the tabs are collapsed.
     *
     * @type {Function}
     * @public
     */
    onCollapse: _propTypes["default"].func,

    /**
     * Called when the tabs are expanded.
     *
     * @type {Function}
     * @public
     */
    onExpand: _propTypes["default"].func,

    /**
     * Called after the popup's "hide" transition finishes.
     *
     * @type {Function}
     * @public
     */
    onHide: _propTypes["default"].func,

    /**
     * Called when a tab is selected
     *
     * @type {Function}
     * @public
    */
    onSelect: _propTypes["default"].func,

    /**
     * Called after the popup's "show" transition finishes.
     *
     * @type {Function}
     * @public
     */
    onShow: _propTypes["default"].func,

    /**
     * Called when the tab collapse or expand animation completes.
     *
     * Event payload includes:
     * * `type` - Always set to "onTabAnimationEnd"
     * * `collapsed` - `true` when the tabs are collapsed
     *
     * @type {Function}
     * @public
     */
    onTabAnimationEnd: _propTypes["default"].func,

    /**
     * Controls the visibility of the Popup.
     *
     * By default, the Popup and its contents are not rendered until `open`.
     *
     * @type {Boolean}
     * @public
     */
    open: _propTypes["default"].bool,

    /**
     * Orientation of the tabs.
     *
     * @type {('vertical')}
     * @private
     */
    orientation: _propTypes["default"].oneOf(['vertical']),

    /**
     * Position of the Popup on the screen.
     *
     * @type {'left'}
     * @default 'left'
     * @private
     */
    position: _propTypes["default"].oneOf(['left']),

    /**
     * Scrim type.
     *
     * * Values: `'transparent'`, `'translucent'`, or `'none'`.
     *
     * `'none'` is not compatible with `spotlightRestrict` of `'self-only'`, use a transparent scrim
     * to prevent mouse focus when using popup.
     *
     * @type {('transparent'|'translucent'|'none')}
     * @default 'translucent'
     * @public
     */
    scrimType: _propTypes["default"].oneOf(['transparent', 'translucent', 'none']),

    /**
     * The container id for {@link spotlight/Spotlight}.
     *
     * @type {String}
     * @public
     */
    spotlightId: _propTypes["default"].string,

    /**
     * Restricts or prioritizes navigation when focus attempts to leave the popup.
     *
     * It can be either `'none'`, `'self-first'`, or `'self-only'`.
     *
     * Note: The ready-to-use [Popup]{@link sandstone/Popup.Popup} component only supports
     * `'self-first'` and `'self-only'`.
     *
     * @type {('none'|'self-first'|'self-only')}
     * @public
     */
    spotlightRestrict: _propTypes["default"].oneOf(['none', 'self-first', 'self-only'])
  },
  defaultProps: {
    dimensions: {
      tabs: {
        collapsed: 216,
        normal: 660
      },
      content: {
        expanded: 1320,
        normal: 1320
      }
    },
    orientation: 'vertical',
    position: 'left',
    scrimType: 'translucent'
  },
  styles: {
    css: _PopupTabLayoutModule["default"],
    className: 'popupTabLayout'
  },
  computed: {
    className: function className(_ref) {
      var scrimType = _ref.scrimType,
          styler = _ref.styler;
      return styler.append("scrim".concat((0, _util.cap)(scrimType)));
    }
  },
  render: function render(_ref2) {
    var children = _ref2.children,
        rest = _objectWithoutProperties(_ref2, ["children"]);

    // Extract all relevant popup props
    var popupProps = {};

    for (var prop in rest) {
      if (popupPropList.indexOf(prop) >= 0) {
        popupProps[prop] = rest[prop];
        delete rest[prop];
      }
    }

    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_Popup["default"], _objectSpread(_objectSpread({}, popupProps), {}, {
      css: _PopupTabLayoutModule["default"],
      noAlertRole: true,
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_TabLayout["default"], _objectSpread(_objectSpread({}, rest), {}, {
        css: _PopupTabLayoutModule["default"],
        align: "start",
        anchorTo: "left",
        type: "popup",
        children: children
      }))
    }));
  }
});
/**
 * Add behaviors to PopupTabLayout.
 *
 * @class PopupTabLayoutDecorator
 * @memberof sandstone/PopupTabLayout
 * @mixes sandstone/Skinnable.Skinnable
 * @hoc
 * @public
 */

exports.PopupTabLayoutBase = PopupTabLayoutBase;
var PopupTabLayoutDecorator = (0, _compose["default"])(_Skinnable["default"]);
/**
 * An instance of [`Popup`]{@link sandstone/Popup.Popup} which restricts the `TabLayout` content to
 * the left side of the screen. The content of `TabLayout` can flex vertically, but not horizontally
 * (fixed width). This is typically used to switch between several collections of managed views
 * (`TabPanels` and `TabPanel`, also exported from this module).
 *
 * Example:
 *
 * ```jsx
 * 	<PopupTabLayout>
 * 		<Tab title="Tab One">
 * 			<TabPanels>
 * 				<TabPanel>
 * 					<Header title="First Panel" type="compact" />
 * 					<Item>Item 1 in Panel 1</Item>
 * 					<Item>Item 2 in Panel 1</Item>
 * 				</TabPanel>
 * 				<TabPanel>
 * 					<Header title="Second Panel" type="compact" />
 * 					<Item>Item 1 in Panel 2</Item>
 * 					<Item>Item 2 in Panel 2</Item>
 * 				</TabPanel>
 * 			</TabPanels>
 * 		</Tab>
 * 		<Tab title="Tab Two">
 * 			<Item>Goodbye</Item>
 * 		</Tab>
 * 	</PopupTabLayout>
 * ```
 *
 * @class PopupTabLayout
 * @memberof sandstone/PopupTabLayout
 * @ui
 * @public
 */

exports.PopupTabLayoutDecorator = PopupTabLayoutDecorator;
var PopupTabLayout = PopupTabLayoutDecorator(PopupTabLayoutBase);
/**
 * A shortcut to access {@link sandstone/PopupTabLayout.Tab}
 *
 * @name Tab
 * @type {sandstone/PopupTabLayout.Tab}
 * @memberof sandstone/PopupTabLayout.PopupTabLayout
 * @extends sandstone/TabLayout.Tab
 */

exports.PopupTabLayout = PopupTabLayout;
PopupTabLayout.Tab = _TabLayout.Tab;
/**
 * A Tab for use inside this component.
 *
 * @class Tab
 * @memberof sandstone/PopupTabLayout
 * @extends sandstone/TabLayout.Tab
 * @ui
 */

var tabPanelsHandlers = {
  onTransition: (0, _handle.handle)((0, _handle.forward)('onTransition'), function (ev, props, _ref3) {
    var onTransition = _ref3.onTransition;
    onTransition(ev);
  }),
  onKeyDown: (0, _handle.handle)((0, _handle.forward)('onKeyDown'), (0, _handle.forProp)('rtl', false), (0, _handle.forKey)('left'), function (ev, _ref4) {
    var index = _ref4.index;
    return index > 0;
  }, function (_ref5) {
    var target = _ref5.target;
    var next = (0, _target.getTargetByDirectionFromElement)('left', target);

    if (next === null || next && !(0, _container.getContainerNode)((0, _container.getContainersForNode)(target).pop()).contains(next)) {
      return true;
    }

    return false;
  }, function (ev) {
    if ((0, _container.getContainerNode)((0, _container.getContainersForNode)(ev.target).pop()).tagName === 'HEADER') {
      ev.stopPropagation();
      return false;
    }

    return document.querySelector("section.".concat(_PopupTabLayoutModule["default"].body)).contains(ev.target);
  }, (0, _handle.forward)('onBack'), _handle.stop)
};
/**
 * A base component for [`TabPanels`]{@link sandstone/PopupTabLayout.TabPanels} which has
 * left key handler to navigate panels.
 *
 * @class TabPanelsBase
 * @memberof sandstone/PopupTabLayout
 * @extends sandstone/Panels.Panels
 * @ui
 * @public
 */

var TabPanelsBase = function TabPanelsBase(_ref6) {
  var rtl = _ref6.rtl,
      rest = _objectWithoutProperties(_ref6, ["rtl"]);

  var onTransition = (0, _react.useContext)(_TabLayout.TabLayoutContext);
  var handlers = (0, _useHandlers["default"])(tabPanelsHandlers, _objectSpread({
    rtl: rtl
  }, rest), {
    onTransition: onTransition
  });
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_Panels["default"], _objectSpread(_objectSpread({
    noCloseButton: true
  }, rest), {}, {
    css: _PopupTabLayoutModule["default"]
  }, handlers));
};

exports.TabPanelsBase = TabPanelsBase;
TabPanelsBase.propTypes = {
  rtl: _propTypes["default"].bool
};
/**
 * A customized version of Panels for use inside this component.
 *
 * @class TabPanels
 * @memberof sandstone/PopupTabLayout
 * @extends sandstone/PopupTabLayout.TabPanelsBase
 * @ui
 * @public
 */

var TabPanels = (0, _I18nDecorator.I18nContextDecorator)({
  rtlProp: 'rtl'
}, TabPanelsBase);
/**
 * Omits the close button.
 *
 * Unlike most components, this prop defaults to `true`. To show the close button, the prop must
 * explicitly set it to `false`:
 *
 * ```
 * <TabPanels noCloseButton={false} />
 * ```
 *
 * @name noCloseButton
 * @memberof sandstone/PopupTabLayout.TabPanels.prototype
 * @type {Boolean}
 * @default true
 * @public
 */

/**
 * A customized version of Panel for use inside this component.
 *
 * @class TabPanel
 * @memberof sandstone/PopupTabLayout
 * @extends sandstone/Panels.Panel
 * @ui
 * @public
 */

exports.TabPanels = TabPanels;

var TabPanel = function TabPanel(_ref7) {
  var spotlightId = _ref7.spotlightId,
      rest = _objectWithoutProperties(_ref7, ["spotlightId"]);

  (0, _react.useEffect)(function () {
    _spotlight["default"].set(spotlightId, {
      partition: true
    });
  }, [spotlightId]);
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_Panels.Panel, _objectSpread(_objectSpread({}, rest), {}, {
    css: _PopupTabLayoutModule["default"],
    hideChildren: false,
    spotlightId: spotlightId
  }));
};

exports.TabPanel = TabPanel;
TabPanel.propTypes = {
  /**
   * The container id for {@link spotlight/Spotlight}.
   *
   * @type {String}
   * @private
   */
  spotlightId: _propTypes["default"].string
};
var _default = PopupTabLayout;
exports["default"] = _default;