"use strict";

var _FloatingLayer = require("@enact/ui/FloatingLayer");

var _enzyme = require("enzyme");

var _ = require("../");

var _jsxRuntime = require("react/jsx-runtime");

var FloatingLayerController = (0, _FloatingLayer.FloatingLayerDecorator)('div');
describe('FlexiblePopupPanels Specs', function () {
  test('should hide previous and next buttons when there is only one panel', function () {
    var subject = (0, _enzyme.mount)( /*#__PURE__*/(0, _jsxRuntime.jsx)(FloatingLayerController, {
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_.FlexiblePopupPanels, {
        open: true,
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_.Panel, {})
      })
    }));
    var expected = 0;
    var actual = subject.find('Button').length;
    subject.unmount();
    expect(actual).toBe(expected);
  });
  test('should show previous and next buttons when there is more than one panel', function () {
    var subject = (0, _enzyme.mount)( /*#__PURE__*/(0, _jsxRuntime.jsx)(FloatingLayerController, {
      children: /*#__PURE__*/(0, _jsxRuntime.jsxs)(_.FlexiblePopupPanels, {
        open: true,
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_.Panel, {}), /*#__PURE__*/(0, _jsxRuntime.jsx)(_.Panel, {}), /*#__PURE__*/(0, _jsxRuntime.jsx)(_.Panel, {})]
      })
    }));
    var expected = 2;
    var actual = subject.find('Button').length;
    subject.unmount();
    expect(actual).toBe(expected);
  });
  test('should show previous button when using `prevButton` on the only panel', function () {
    var subject = (0, _enzyme.mount)( /*#__PURE__*/(0, _jsxRuntime.jsx)(FloatingLayerController, {
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_.FlexiblePopupPanels, {
        open: true,
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_.Panel, {
          prevButton: true
        })
      })
    }));
    var expected = 1;
    var actual = subject.find('Button').length;
    subject.unmount();
    expect(actual).toBe(expected);
  });
  test('should show previous button when using `nextButton` on the only panel', function () {
    var subject = (0, _enzyme.mount)( /*#__PURE__*/(0, _jsxRuntime.jsx)(FloatingLayerController, {
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_.FlexiblePopupPanels, {
        open: true,
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_.Panel, {
          nextButton: true
        })
      })
    }));
    var expected = 1;
    var actual = subject.find('Button').length;
    subject.unmount();
    expect(actual).toBe(expected);
  });
  test('should hide previous button on all panels when `prevButtonVisibility` is set to "never"', function () {
    var subject = (0, _enzyme.mount)( /*#__PURE__*/(0, _jsxRuntime.jsx)(FloatingLayerController, {
      children: /*#__PURE__*/(0, _jsxRuntime.jsxs)(_.FlexiblePopupPanels, {
        prevButtonVisibility: "never",
        open: true,
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_.Panel, {}), /*#__PURE__*/(0, _jsxRuntime.jsx)(_.Panel, {})]
      })
    }));
    var expected = 1;
    var actual = subject.find('Button').length;
    subject.unmount();
    expect(actual).toBe(expected);
  });
  test('should hide next button on all panels when `nextButtonVisibility` is set to "never"', function () {
    var subject = (0, _enzyme.mount)( /*#__PURE__*/(0, _jsxRuntime.jsx)(FloatingLayerController, {
      children: /*#__PURE__*/(0, _jsxRuntime.jsxs)(_.FlexiblePopupPanels, {
        nextButtonVisibility: "never",
        open: true,
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_.Panel, {}), /*#__PURE__*/(0, _jsxRuntime.jsx)(_.Panel, {})]
      })
    }));
    var expected = 1;
    var actual = subject.find('Button').length;
    subject.unmount();
    expect(actual).toBe(expected);
  });
  test('should show previous button on the only panel when `prevButtonVisibility` set to "always"', function () {
    var subject = (0, _enzyme.mount)( /*#__PURE__*/(0, _jsxRuntime.jsx)(FloatingLayerController, {
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_.FlexiblePopupPanels, {
        prevButtonVisibility: "always",
        open: true,
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_.Panel, {})
      })
    }));
    var expected = 1;
    var actual = subject.find('Button').length;
    subject.unmount();
    expect(actual).toBe(expected);
  });
  test('should show next button on the only panel when `nextButtonVisibility` set to "always"', function () {
    var subject = (0, _enzyme.mount)( /*#__PURE__*/(0, _jsxRuntime.jsx)(FloatingLayerController, {
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_.FlexiblePopupPanels, {
        nextButtonVisibility: "always",
        open: true,
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_.Panel, {})
      })
    }));
    var expected = 1;
    var actual = subject.find('Button').length;
    subject.unmount();
    expect(actual).toBe(expected);
  });
  test('should hide previous button on panels that override using `prevButton={false}`', function () {
    var subject = (0, _enzyme.mount)( /*#__PURE__*/(0, _jsxRuntime.jsx)(FloatingLayerController, {
      children: /*#__PURE__*/(0, _jsxRuntime.jsxs)(_.FlexiblePopupPanels, {
        index: 1,
        open: true,
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_.Panel, {}), /*#__PURE__*/(0, _jsxRuntime.jsx)(_.Panel, {
          prevButton: false
        })]
      })
    }));
    var expected = 1;
    var actual = subject.find('Button').length;
    subject.unmount();
    expect(actual).toBe(expected);
  });
  test('should hide next button on panels that override using `nextButton={false}`', function () {
    var subject = (0, _enzyme.mount)( /*#__PURE__*/(0, _jsxRuntime.jsx)(FloatingLayerController, {
      children: /*#__PURE__*/(0, _jsxRuntime.jsxs)(_.FlexiblePopupPanels, {
        index: 0,
        open: true,
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_.Panel, {
          nextButton: false
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_.Panel, {})]
      })
    }));
    var expected = 1;
    var actual = subject.find('Button').length;
    subject.unmount();
    expect(actual).toBe(expected);
  });
  test('should hide previous button when `prevButtonVisibility` prop is set to always and panel overrides using `prevButton={false}`', function () {
    var subject = (0, _enzyme.mount)( /*#__PURE__*/(0, _jsxRuntime.jsx)(FloatingLayerController, {
      children: /*#__PURE__*/(0, _jsxRuntime.jsxs)(_.FlexiblePopupPanels, {
        index: 1,
        prevButtonVisibility: "always",
        open: true,
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_.Panel, {}), /*#__PURE__*/(0, _jsxRuntime.jsx)(_.Panel, {
          prevButton: false
        })]
      })
    }));
    var expected = 1;
    var actual = subject.find('Button').length;
    subject.unmount();
    expect(actual).toBe(expected);
  });
  test('should hide next button when `nextButtonVisibility` prop is set to always and panel overrides using `nextButton={false}`', function () {
    var subject = (0, _enzyme.mount)( /*#__PURE__*/(0, _jsxRuntime.jsx)(FloatingLayerController, {
      children: /*#__PURE__*/(0, _jsxRuntime.jsxs)(_.FlexiblePopupPanels, {
        index: 0,
        nextButtonVisibility: "always",
        open: true,
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_.Panel, {
          nextButton: false
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_.Panel, {})]
      })
    }));
    var expected = 1;
    var actual = subject.find('Button').length;
    subject.unmount();
    expect(actual).toBe(expected);
  });
  test('should close on back key when on first panel', function () {
    var map = {};
    window.addEventListener = jest.fn(function (event, cb) {
      map[event] = cb;
    });
    var spy = jest.fn();
    var subject = (0, _enzyme.mount)( /*#__PURE__*/(0, _jsxRuntime.jsx)(FloatingLayerController, {
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_.FlexiblePopupPanels, {
        index: 0,
        onClose: spy,
        open: true,
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_.Panel, {})
      })
    }));
    map.keyup({
      type: 'keyup',
      currentTarget: window,
      keyCode: 27
    });
    var expected = 1;
    var actual = spy.mock.calls.length;
    subject.unmount();
    expect(actual).toBe(expected);
  });
  test('should go back on back key when not on first panel', function () {
    var map = {};
    window.addEventListener = jest.fn(function (event, cb) {
      map[event] = cb;
    });
    var spy = jest.fn();
    var subject = (0, _enzyme.mount)( /*#__PURE__*/(0, _jsxRuntime.jsx)(FloatingLayerController, {
      children: /*#__PURE__*/(0, _jsxRuntime.jsxs)(_.FlexiblePopupPanels, {
        index: 1,
        onBack: spy,
        open: true,
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_.Panel, {}), /*#__PURE__*/(0, _jsxRuntime.jsx)(_.Panel, {})]
      })
    }));
    map.keyup({
      type: 'keyup',
      currentTarget: window,
      keyCode: 27
    });
    var expected = 1;
    var actual = spy.mock.calls.length;
    subject.unmount();
    expect(actual).toBe(expected);
  });
  it('should correctly assign the fullHeight class', function () {
    var subject = (0, _enzyme.mount)( /*#__PURE__*/(0, _jsxRuntime.jsx)(FloatingLayerController, {
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_.FlexiblePopupPanels, {
        fullHeight: true,
        open: true,
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_.Panel, {})
      })
    }));
    var expected = 'fullHeight';
    var actual = subject.find('Popup').prop('className');
    expect(actual).toContain(expected);
  });
});