"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ItemDecorator = exports.ItemBase = exports.Item = exports["default"] = void 0;

var _classnames = _interopRequireDefault(require("classnames"));

var _propTypes = _interopRequireDefault(require("@enact/core/internal/prop-types"));

var _kind = _interopRequireDefault(require("@enact/core/kind"));

var _Spottable = _interopRequireDefault(require("@enact/spotlight/Spottable"));

var _Slottable = _interopRequireDefault(require("@enact/ui/Slottable"));

var _Item = require("@enact/ui/Item");

var _Layout = require("@enact/ui/Layout");

var _Pure = _interopRequireDefault(require("@enact/ui/internal/Pure"));

var _compose = _interopRequireDefault(require("ramda/src/compose"));

var _propTypes2 = _interopRequireDefault(require("prop-types"));

var _Marquee = require("../Marquee");

var _Skinnable = _interopRequireDefault(require("../Skinnable"));

var _ItemModule = _interopRequireDefault(require("./Item.module.css"));

var _jsxRuntime = require("react/jsx-runtime");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

// eslint-disable-next-line enact/prop-types
var ItemContent = function ItemContent(_ref) {
  var _LabelPositionClassna;

  var content = _ref.content,
      css = _ref.css,
      label = _ref.label,
      labelPosition = _ref.labelPosition,
      marqueeOn = _ref.marqueeOn,
      rest = _objectWithoutProperties(_ref, ["content", "css", "label", "labelPosition", "marqueeOn"]);

  var LabelPositionClassname = (_LabelPositionClassna = {}, _defineProperty(_LabelPositionClassna, css.labelAbove, labelPosition === 'above'), _defineProperty(_LabelPositionClassna, css.labelAfter, labelPosition === 'after'), _defineProperty(_LabelPositionClassna, css.labelBefore, labelPosition === 'before'), _defineProperty(_LabelPositionClassna, css.labelBelow, labelPosition === 'below'), _LabelPositionClassna);
  var orientation = labelPosition === 'above' || labelPosition === 'below' ? 'vertical' : 'horizontal';
  var itemContentClasses = (0, _classnames["default"])(css.itemContent, LabelPositionClassname);
  return !label ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_Layout.Cell, _objectSpread(_objectSpread({}, rest), {}, {
    component: _Marquee.Marquee,
    className: (0, _classnames["default"])(itemContentClasses, css.content),
    marqueeOn: marqueeOn,
    children: content
  })) : /*#__PURE__*/(0, _jsxRuntime.jsx)(_Layout.Cell, _objectSpread(_objectSpread({}, rest), {}, {
    className: itemContentClasses,
    children: /*#__PURE__*/(0, _jsxRuntime.jsxs)(_Layout.Layout, {
      orientation: orientation,
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_Layout.Cell, {
        component: _Marquee.Marquee,
        className: css.content,
        marqueeOn: marqueeOn,
        shrink: true,
        children: content
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_Layout.Cell, {
        component: _Marquee.Marquee,
        className: css.label,
        marqueeOn: marqueeOn,
        shrink: true,
        children: label
      })]
    })
  }));
};

ItemContent.displayName = 'ItemContent';
ItemContent.propTypes = {
  content: _propTypes2["default"].any,
  css: _propTypes2["default"].object,
  label: _propTypes2["default"].any,
  labelPosition: _propTypes2["default"].any
};
/**
 * A Sandstone styled item without any behavior.
 *
 * @class ItemBase
 * @memberof sandstone/Item
 * @extends ui/Item.ItemBase
 * @ui
 * @public
 */

var ItemBase = (0, _kind["default"])({
  name: 'Item',
  propTypes:
  /** @lends sandstone/Item.ItemBase.prototype */
  {
    /**
     * Centers the slots and content.
     *
     * @type {Boolean}
     * @public
     */
    centered: _propTypes2["default"].bool,

    /**
     * Called with a reference to the root component.
     *
     * @type {Object|Function}
     * @public
     */
    componentRef: _propTypes["default"].ref,

    /**
     * Customizes the component by mapping the supplied collection of CSS class names to the
     * corresponding internal elements and states of this component.
     *
     * The following classes are supported:
     *
     * * `item` - The root class name
     * * `slotBefore` - The slot (container) preceding the text of this component
     * * `slotAfter` - The slot (container) following the text of this component
     * * `selected` - Applied to a `selected` button
     *
     * @type {Object}
     * @public
     */
    css: _propTypes2["default"].object,

    /**
     * Applies a disabled style and the control becomes non-interactive.
     *
     * @type {Boolean}
     * @public
     */
    disabled: _propTypes2["default"].bool,

    /**
     * Applies inline styling to the item.
     *
     * @type {Boolean}
     * @public
     */
    inline: _propTypes2["default"].bool,

    /**
     * The label to be displayed along with the text.
     *
     * @type {Node}
     * @public
     */
    label: _propTypes2["default"].node,

    /**
     * The position of the label relative to the primary content, `children`.
     *
     * @type {('above'|'after'|'before'|'below')}
     * @public
     */
    labelPosition: _propTypes2["default"].oneOf(['above', 'after', 'before', 'below']),

    /**
     * Determines what triggers the marquee to start its animation.
     *
     * @type {('focus'|'hover'|'render')}
     * @public
     */
    marqueeOn: _propTypes2["default"].oneOf(['focus', 'hover', 'render']),

    /**
     * Applies a selected style to the component.
     *
     * @type {Boolean}
     * @private
     */
    selected: _propTypes2["default"].bool,

    /**
     * The size of the item.
     *
     * @type {('large'|'small')}
     * @default 'large'
     * @private
     */
    size: _propTypes2["default"].oneOf(['large', 'small']),

    /**
     * Nodes to be inserted after `children`.
     *
     * For LTR locales, the nodes are inserted to the right of the primary content. For RTL
     * locales, the nodes are inserted to the left. If nothing is specified, nothing, not even
     * an empty container, is rendered in this place.
     *
     * @type {Node}
     * @public
     */
    slotAfter: _propTypes2["default"].node,

    /**
     * Nodes to be inserted before `children` and `label`.
     *
     * For LTR locales, the nodes are inserted to the left of the primary content. For RTL
     * locales, the nodes are inserted to the right. If nothing is specified, nothing, not even
     * an empty container, is rendered in this place.
     *
     * @type {Node}
     * @public
     */
    slotBefore: _propTypes2["default"].node
  },
  defaultProps: {
    labelPosition: 'below',
    size: 'large'
  },
  styles: {
    css: _ItemModule["default"],
    publicClassNames: ['item', 'itemContent', 'content', 'label', 'bg', 'slotAfter', 'slotBefore', 'selected']
  },
  computed: {
    className: function className(_ref2) {
      var centered = _ref2.centered,
          label = _ref2.label,
          selected = _ref2.selected,
          size = _ref2.size,
          styler = _ref2.styler;
      return styler.append({
        centered: centered,
        selected: selected,
        hasLabel: label != null
      }, size);
    },
    label: function label(_ref3) {
      var _label = _ref3.label;
      return typeof _label === 'number' ? _label.toString() : _label;
    }
  },
  render: function render(_ref4) {
    var centered = _ref4.centered,
        children = _ref4.children,
        componentRef = _ref4.componentRef,
        css = _ref4.css,
        inline = _ref4.inline,
        label = _ref4.label,
        labelPosition = _ref4.labelPosition,
        marqueeOn = _ref4.marqueeOn,
        slotAfter = _ref4.slotAfter,
        slotBefore = _ref4.slotBefore,
        rest = _objectWithoutProperties(_ref4, ["centered", "children", "componentRef", "css", "inline", "label", "labelPosition", "marqueeOn", "slotAfter", "slotBefore"]);

    delete rest.size;
    var keys = Object.keys(rest);
    var voiceProps = !keys.includes('data-webos-voice-label') && !keys.includes('data-webos-voice-labels') && label && typeof label === 'string' && children && children[0] && typeof children[0] === 'string' ? {
      'data-webos-voice-labels': JSON.stringify([label, children[0]])
    } : {};
    return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_Item.ItemBase, _objectSpread(_objectSpread(_objectSpread({
      "data-webos-voice-intent": "Select",
      component: _Layout.Row,
      align: centered ? 'center center' : 'center',
      ref: componentRef
    }, voiceProps), rest), {}, {
      inline: inline,
      css: css,
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: css.bg
      }), slotBefore ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_Layout.Cell, {
        className: css.slotBefore,
        shrink: true,
        children: slotBefore
      }) : null, /*#__PURE__*/(0, _jsxRuntime.jsx)(ItemContent, {
        content: children,
        css: css,
        label: label,
        labelPosition: labelPosition,
        marqueeOn: marqueeOn,
        shrink: inline
      }), slotAfter ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_Layout.Cell, {
        className: css.slotAfter,
        shrink: true,
        children: slotAfter
      }) : null]
    }));
  }
});
/**
 * Sandstone specific item behaviors to apply to [Item]{@link sandstone/Item.ItemBase}.
 *
 * @class ItemDecorator
 * @hoc
 * @memberof sandstone/Item
 * @mixes ui/Item.ItemDecorator
 * @mixes ui/Slottable.Slottable
 * @mixes spotlight/Spottable.Spottable
 * @mixes sandstone/Marquee.MarqueeController
 * @mixes sandstone/Skinnable.Skinnable
 * @public
 */

exports.ItemBase = ItemBase;
var ItemDecorator = (0, _compose["default"])(_Item.ItemDecorator, (0, _Slottable["default"])({
  slots: ['label', 'slotAfter', 'slotBefore']
}), _Spottable["default"], (0, _Marquee.MarqueeController)({
  marqueeOnFocus: true,
  invalidateProps: ['inline']
}), _Skinnable["default"]);
/**
 * A Sandstone styled item with built-in support for marqueed text, and Spotlight focus.
 *
 * Usage:
 * ```
 * <Item>Item Content</Item>
 * ```
 *
 * @class Item
 * @memberof sandstone/Item
 * @extends sandstone/Item.ItemBase
 * @mixes sandstone/Item.ItemDecorator
 * @ui
 * @public
 */

exports.ItemDecorator = ItemDecorator;
var Item = (0, _Pure["default"])(ItemDecorator(ItemBase));
exports.Item = Item;
var _default = Item;
exports["default"] = _default;