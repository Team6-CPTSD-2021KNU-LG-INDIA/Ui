"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "AlertImage", {
  enumerable: true,
  get: function get() {
    return _AlertImage["default"];
  }
});
exports.AlertBase = exports.Alert = exports["default"] = void 0;

var _kind = _interopRequireDefault(require("@enact/core/kind"));

var _util = require("@enact/core/util");

var _IdProvider = _interopRequireDefault(require("@enact/ui/internal/IdProvider"));

var _Layout = _interopRequireWildcard(require("@enact/ui/Layout"));

var _Slottable = _interopRequireDefault(require("@enact/ui/Slottable"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = require("react");

var _BodyText = _interopRequireDefault(require("../BodyText"));

var _Heading = _interopRequireDefault(require("../Heading"));

var _Popup = _interopRequireDefault(require("../Popup"));

var _AlertImage = _interopRequireDefault(require("./AlertImage"));

var _AlertModule = _interopRequireDefault(require("./Alert.module.css"));

var _jsxRuntime = require("react/jsx-runtime");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// when Alert type is "fullscreen", the body content for string children should be centered
var CenteredBodyText = function CenteredBodyText(props) {
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_BodyText["default"], _objectSpread(_objectSpread({}, props), {}, {
    centered: true
  }));
};
/**
 * A modal Alert component.
 *
 * This component is most often not used directly but may be composed within another component as it
 * is within [Alert]{@link sandstone/Alert.Alert}.
 *
 * @class AlertBase
 * @memberof sandstone/Alert
 * @ui
 * @public
 */


var AlertBase = (0, _kind["default"])({
  name: 'Alert',
  propTypes:
  /** @lends sandstone/Alert.AlertBase.prototype */
  {
    /**
     * Buttons to be included under the component.
     *
     * Typically, up to 3 buttons are used.
     *
     * @type {Element|Element[]}
     * @public
     */
    buttons: _propTypes["default"].oneOfType([_propTypes["default"].element, _propTypes["default"].arrayOf(_propTypes["default"].element)]),

    /**
     * The contents of the body of the component.
     *
     * Only shown when `type="overlay"`. If `children` is text-only, it will be wrapped with
     * [BodyText]{@link sandstone/BodyText}.
     *
     * @type {Node}
     * @public
     */
    children: _propTypes["default"].node,

    /**
     * The `id` of Alert referred to when generating ids for `'title'` and `'buttons'`.
     *
     * @type {String}
     * @private
     */
    id: _propTypes["default"].string,

    /**
     * Image to be included in the Alert component.
     *
     * It is recommended to use the `AlertImage` component.
     *
     * @type {Element}
     * @public
     */
    image: _propTypes["default"].element,

    /**
     * Called when the user requests to close the Alert.
     *
     * This also includes pressing the cancel key.
     *
     * @type {Function}
     * @public
     */
    onClose: _propTypes["default"].func,

    /**
     * Called after the transition to hide the Alert has finished.
     *
     * @type {Function}
     * @public
     */
    onHide: _propTypes["default"].func,

    /**
     * Opens the Alert.
     *
     * @type {Boolean}
     * @default false
     * @public
     */
    open: _propTypes["default"].bool,

    /**
     * Assign a skin.
     *
     * @type {String}
     * @private
     */
    skin: _propTypes["default"].string,

    /**
     * The primary text displayed.
     *
     * Only shown when `type="fullscreen"`.
     *
     * @type {String}
     * @public
     */
    title: _propTypes["default"].string,

    /**
     * Type of popup.
     *
     * There are two types:
     *
     * * `fullscreen` - Full screen popup
     * * `overlay` - Popup in the center of the screen
     *
     * @type {('fullscreen'|'overlay')}
     * @default 'fullscreen'
     * @public
     */
    type: _propTypes["default"].oneOf(['fullscreen', 'overlay'])
  },
  defaultProps: {
    open: false,
    type: 'fullscreen'
  },
  styles: {
    css: _AlertModule["default"],
    className: 'alert'
  },
  computed: {
    buttons: function buttons(_ref) {
      var _buttons = _ref.buttons;
      return (0, _util.mapAndFilterChildren)(_buttons, function (button, index) {
        return /*#__PURE__*/(0, _jsxRuntime.jsx)(_Layout.Cell, {
          className: _AlertModule["default"].buttonCell,
          shrink: true,
          children: button
        }, "button".concat(index));
      }) || null;
    },
    contentComponent: function contentComponent(_ref2) {
      var children = _ref2.children,
          type = _ref2.type;

      if (typeof children === 'string' || Array.isArray(children) && children.every(function (child) {
        return child == null || typeof child === 'string';
      })) {
        return type === 'fullscreen' ? CenteredBodyText : _BodyText["default"];
      }
    },
    className: function className(_ref3) {
      var buttons = _ref3.buttons,
          image = _ref3.image,
          title = _ref3.title,
          type = _ref3.type,
          styler = _ref3.styler;
      return styler.append({
        maxButtons: buttons && _react.Children.toArray(buttons).filter(Boolean).length > 2,
        noImage: !image,
        noTitle: type === 'fullscreen' && !title
      }, type);
    },
    skin: function skin(_ref4) {
      var _skin = _ref4.skin,
          type = _ref4.type;
      return _skin || (type === 'overlay' ? 'light' : 'neutral');
    }
  },
  render: function render(_ref5) {
    var buttons = _ref5.buttons,
        contentComponent = _ref5.contentComponent,
        children = _ref5.children,
        id = _ref5.id,
        image = _ref5.image,
        title = _ref5.title,
        type = _ref5.type,
        rest = _objectWithoutProperties(_ref5, ["buttons", "contentComponent", "children", "id", "image", "title", "type"]);

    var fullscreen = type === 'fullscreen';
    var position = type === 'overlay' ? 'bottom' : type;
    var layoutOrientation = fullscreen ? 'vertical' : 'horizontal';
    var showTitle = fullscreen && title;
    var ariaLabelledBy = (showTitle ? "".concat(id, "_title ") : '') + "".concat(id, "_content ").concat(id, "_buttons");
    return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
      "aria-owns": id,
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_Popup["default"], _objectSpread(_objectSpread({}, rest), {}, {
        id: id,
        noAnimation: true,
        "aria-labelledby": ariaLabelledBy,
        css: _AlertModule["default"],
        position: position,
        children: /*#__PURE__*/(0, _jsxRuntime.jsxs)(_Layout["default"], {
          align: "center center",
          orientation: layoutOrientation,
          children: [image ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_Layout.Cell, {
            shrink: true,
            className: _AlertModule["default"].alertImage,
            children: image
          }) : null, showTitle ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_Layout.Cell, {
            shrink: true,
            children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_Heading["default"], {
              size: "title",
              alignment: "center",
              className: _AlertModule["default"].title,
              id: "".concat(id, "_title"),
              children: title
            })
          }) : null, /*#__PURE__*/(0, _jsxRuntime.jsx)(_Layout.Cell, {
            shrink: true,
            align: fullscreen ? 'center' : '',
            component: contentComponent,
            className: _AlertModule["default"].content,
            id: "".concat(id, "_content"),
            children: children
          }), buttons ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_Layout.Cell, {
            align: fullscreen ? '' : 'end',
            shrink: true,
            className: _AlertModule["default"].buttonContainer,
            children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_Layout["default"], {
              align: "center",
              orientation: "vertical",
              id: "".concat(id, "_buttons"),
              children: buttons
            })
          }) : null]
        })
      }))
    });
  }
});
/**
 * A modal Alert component, ready to use in Sandstone applications.
 *
 * `Alert` may be used to interrupt a workflow to receive feedback from the user.
 * The dialog consists of a title, a message, and an area for additional
 * [buttons]{@link sandstone/Alert.Alert.buttons}.
 *
 * Usage:
 * ```
 * <Alert
 *   open={this.state.open}
 *   title="An Important Alert"
 * >
 *   <image>
 *     <AlertImage src={this.state.src} type="thumbnail" />
 *   </image>
 *
 *   Body text for alert. Components may also be used here for greater customizability.
 *
 *   <buttons>
 *     <Button>Button 1</Button>
 *     <Button>Button 2</Button>
 *   </buttons>
 * </Alert>
 * ```
 *
 * @class Alert
 * @memberof sandstone/Alert
 * @extends sandstone/Alert.AlertBase
 * @mixes ui/Slottable.Slottable
 * @ui
 * @public
 */

exports.AlertBase = AlertBase;
var Alert = (0, _IdProvider["default"])({
  generateProp: null,
  prefix: 'a_'
}, (0, _Slottable["default"])({
  slots: ['title', 'buttons', 'image']
}, AlertBase));
exports.Alert = Alert;
var _default = Alert;
exports["default"] = _default;